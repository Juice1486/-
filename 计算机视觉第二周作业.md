#                                           计算机视觉第二周实验作业

### 一、作业要求

基本要求：输入彩色图像，通过自己设计的算法代码编写，实现输入图像的灰度化、固定阈值的二值化，并能进行亮度调整。拓展要求：在基本要求的基础上，实现通道提取，可变化阈值的二值化，自适应二值化，能进行对比度、饱和度的调整。

### 二、实验原理

**彩色图像**：正如我们所知，图像是由***像素***构成的。我们平时所说的标清、高清、超清、4K分别对应为640x480 、

1024x720p 、1920x1080p 、3840x2160 。像素就是在这一个大的方格中的单元格。像素作为彩色图片最基本的单位，像素有着三原色RGB。我们可以数学公式来表示一个像素。若有数学公式
$$
f (x , y) = （r ， g ，b）
$$
这个就表示在图像中横坐标为x，纵坐标为y的像素对应的三原色的值为（r ， g ，b）。r、g、b取值的范围为（0~255）。

**灰色图像**：与彩色图像不同的是，灰色图像像素的表示有很大不同。灰色图像像素表示为f (x , y) =  t，t为一个具体的数值，而彩色图像就是一个具体的向量。所以由彩色向量转化为灰色图像只需要将一个具体的向量转化为一个具体的值就可以了。由彩色图像到灰色图像对应的公式为：
$$
0.21*r+0.72*g++0.07*b = 灰度值
$$
按照这样的方法就可以将一个彩色图像转化为一个灰度图像。

**二值图像**：二值图像是一个最为简洁的图像，可以用极为简单的表达，反映出许多信息。二值图像可以在灰度化图像的基础上进一步得到。二值图像对应的函数关系：
$$
f(x,y) = \left\{
 \begin{matrix}
 255&x<=th\\
 0&x>th
 
  \end{matrix}
  \right\} \tag{2}
$$
th代表的是阈值，如果大于就为白色，小于就为黑色，所以我们可以通过设置阈值而得到不同阈值下不同的二值图像。

**对比度**：对比度指的是一幅图像中明暗区域**<u>最亮的白和最暗的黑</u>**之间不同亮度层级的测量，差异范围越大代表对比越大，差异范围越小代表对比越小 。对于对比度的处理，我们可以使用一个系数，，使得彩色图像对应的像素值同时乘以这一个像素。这样就可以使得大得越大，小的越小，就可以达到对比度的效果。

**亮度处理**：对于亮度处理非常简单，正如我们所知，三原色中（0,0,0,）代表黑色，（255,255,255）代表白色。我们我们使得彩色图像同时相加或者减去一个相同的数，这样就可以实现亮度的调整

**HSL**：HSL即<u>色相、饱和度、亮度</u>（英语：Hue, Saturation, Lightness）。***色相***（H）是色彩的基本属性，就是平常所说的颜色名称，如红色、黄色等。***饱和度***（S）是指色彩的纯度，越高色彩越纯，低则逐渐变灰，取0-100%的数值。明度（V），亮度（L），取0-100%。

**饱和度**：实现饱和度的修改较为复杂，首先需要将rgb图像转化为hsv图像并求得求得相应的亮度和饱和度，转化规则如下：
$$
L=1/2(max+min)\\
S=\left\{
 \begin{matrix}
\frac {max-min}{max+min}&L<=1/2\\
 \frac {max-min}{2-(max+min)}&L>1/2
 
  \end{matrix}
  \right\} \tag{2}
$$
其中min和max表示的是r,g,b三种颜色中的最大最小值

设置饱和度增量increment，范围为-1至1，并由此计算出适用于RGB空间的调整系数进行饱和度调整 

当增量i (increment) >= 0时，此时饱和度采用指数型增长方式调整。考虑到当前饱和度s与增量i之和可能大于1，超出饱和度上限，故仅仅考虑i作为调整依据不妥。在此选定当i+s大于1时，取s补数作为调整依据（s补数越大，调整越大）；当i+s小于1，取i作为调整依据（i越大，调整越大）。RGB空间的调整系数***alpha***公式如下：
$$
alpha=\left\{
 \begin{matrix}
\frac {1-s}{s}&i+s>=1\\
 \frac {i}{1-i}&i+s<1
 
  \end{matrix}
  \right\} \tag{2}
$$
 当增量i (increment) < 0时，此时饱和度采用线性减弱方式调整。考虑到当i取-1时，R、G、B值会相等，可以直接采用线性的方式作调整。RGB空间的调整系数***alpha***如下： 
$$
alpha=i
$$


### 三、实验结果及截图

#### 1、实现图像的灰度化、二值化

彩色图像：

![1663295642018](C:\Users\HP\AppData\Local\Temp\1663295642018.png)

灰度图像：

![1663295699384](C:\Users\HP\AppData\Local\Temp\1663295699384.png)

图像的二值化：

![1663295846631](C:\Users\HP\AppData\Local\Temp\1663295846631.png)

拖动滑条就可以实现不同阈值下二值图像的变化，我们这里将滑条拖动至30，可以明显的看到变化：

![1663295916976](C:\Users\HP\AppData\Local\Temp\1663295916976.png)

实验的相关python代码：

```python
import numpy as np
import matplotlib.pyplot as plt
import cv2 as cv

th = 0.5
img_path = '图片路径'
img = cv.imread(img_path)
img2 = np.copy(img)

#图像灰度化
def RGB2GRAY(img):
    return 0.21*img[:,:,0]+0.71*img[:,:,1]+0.07

#图像二值化
def Binarzation(x):
    global th,img2
    gray = RGB2GRAY(img/255)
    bin = np.copy(gray)
    th = cv.getTrackbarPos('2-value', 'image')
    th = th * 0.01
    bin[gray >= th] = 1
    bin[gray < th] =0
    img2 = bin

gray = RGB2GRAY(img/255)
cv.namedWindow('image')
cv.createTrackbar('2-value','image',0,100,Binar
cv.setTrackbarPos('2-value','image',50)
while (True):#时刻刷新图像
    cv.imshow('image',img2)#这里更换图像内容，彩色图像就更改为彩色图像的img
    if cv.waitKey(1) == ord('q'):
        break
cv.waitKey(0)
cv.destroyAllWindows()
```

#### 2、实现呢图像对比度和亮度的调整

更改亮度前（alpha表示对比度，beta表示的是亮度)：

![1663296245427](C:\Users\HP\AppData\Local\Temp\1663296245427.png)

我们将亮度由30更改至120：

![1663296335949](C:\Users\HP\AppData\Local\Temp\1663296335949.png)

更改对比度前：

![1663296396296](C:\Users\HP\AppData\Local\Temp\1663296396296.png)

将对比度更改至180后：

![1663296447603](C:\Users\HP\AppData\Local\Temp\1663296447603.png)

对应代码如下：

```python
import cv2
import numpy as np

alpha = 0.3 # 对比度
beta = 80   # 亮度

img_path = "./Trla.jpg"
img = cv2.imread(img_path)
img2 = cv2.imread(img_path)


# 修改对比度
def updateAlpha(y):
    global alpha, img, img2
    alpha = cv2.getTrackbarPos('Alpha', 'image')#得到滑动条的值
    alpha = alpha * 0.01
    img = np.uint8(np.clip((alpha * img2 + beta), 0, 255))#修改对比度，主要产生对比的原因是因为自身的初值原因

# 修改亮度
def updateBeta(y):
    global beta, img, img2
    beta = cv2.getTrackbarPos('Beta', 'image')
    img = np.uint8(np.clip((alpha * img2 + beta), 0, 255))#得到亮度，数值越大，亮度就越大
    print(alpha)

# 创建窗口
cv2.namedWindow('image')
cv2.createTrackbar('Alpha', 'image', 0, 300, updateAlpha)#创建滑动条
cv2.createTrackbar('Beta', 'image', 0, 200, updateBeta)
cv2.setTrackbarPos('Alpha', 'image', 80)#将滑动条的初始值设置为80
cv2.setTrackbarPos('Beta', 'image', 80)

while (True):#时刻刷新图像
    cv2.imshow('image', img)
    if cv2.waitKey(1) == ord('q'):
        break

cv2.destroyAllWindows()
```

#### 3、通道提取饱和度的调整

通道提取,python实现通道提取十分简单，彩色图像对应的是一个三维向量，所以我们每次只取一维就行

代码如下：

```python
import cv2 as cv

img = cv.imread('./Trla.jpg')
r = img[:,:,0]
g = img[:,:,1]
b = img[:,:,2]
cv.imshow('r',r)#r通道
cv.imshow('g',g)#g通道
cv.imshow('b',b)#b通道
cv.waitKey(0)
cv.destroyAllWindows()
```

饱和度的调整,饱和度未更改前：

![1663297247111](C:\Users\HP\AppData\Local\Temp\1663297247111.png)

将饱和度更改至150后：

![1663297282070](C:\Users\HP\AppData\Local\Temp\1663297282070.png)

代码如下：

```python
import numpy as np
import cv2 as cv
import matplotlib.pylab as plt

img = cv.imread('./Trla.jpg')
img_out = img
increment = 0.5

def getHsl(x):
    global increment,img_out
    increment = cv.getTrackbarPos('Saturation','image')
    increment = (increment - 100)/100
    img_temp = img * 1.0
    img_out = img
    img_min = img_temp.min(axis = 2)
    img_max = img_temp.max(axis = 2)

    #获取空间饱和度和亮度,L为亮度,s为饱和度
    delta = (img_max - img_min)/255
    value = (img_max + img_min)/255
    L = value/2
    
    mask_1 = L < 0.5
    s1 = delta/(value)
    s2 = delta/(2 - value)
    s = s1 * mask_1 + s2 * (1 - mask_1)
    if increment >= 0 :
        temp = increment + s
        mask_2 = temp >  1
        alpha_1 = s
        alpha_2 = s * 0 + 1 - increment
        alpha = alpha_1 * mask_2 + alpha_2 * (1 - mask_2)
        alpha = 1/alpha -1 
        img_out[:, :, 0] = img_temp[:, :, 0] + (img_temp[:, :, 0] - L * 255.0) * alpha
        img_out[:, :, 1] = img_temp[:, :, 1] + (img_temp[:, :, 1] - L * 255.0) * alpha
        img_out[:, :, 2] = img_temp[:, :, 2] + (img_temp[:, :, 2] - L * 255.0) * alpha
        
    # 增量小于0，饱和度线性衰减
    else:
        alpha = increment
        img_out[:, :, 0] = img_temp[:, :, 0] + (img_temp[:, :, 0] - L * 255.0) * alpha
        img_out[:, :, 1] = img_temp[:, :, 1] + (img_temp[:, :, 1] - L * 255.0) * alpha
        img_out[:, :, 2] = img_temp[:, :, 2] + (img_temp[:, :, 2] - L * 255.0) * alpha
    
    # RGB颜色上下限处理(小于0取0，大于1取1)
    img_out = np.uint8(np.clip(img_out, 0, 255))

cv.namedWindow('image')
cv.createTrackbar('Saturation','image',0,200,getHsl)
cv.setTrackbarPos('Saturation','image',150)
while True:
    cv.imshow('image',img_out)
    if cv.waitKey(1) == ord('q'):
        break

cv.destroyAllWindows()
```

### 四、实验总结

本次实验是我刚开始血洗计算机视觉处理，一开始接触觉得无从下手。特别是作业要求有拖动条也不知道怎么处理，但在网上翻阅资料之后，也并没有遇到什么困难，很轻松就解决了这个问题。所以一个问题在你没去了解之前，就不要轻易套上一个困难的标签，其实根本没有你想的那么复杂，只是你的思考方式不对罢了。